# backend/seo_pages_content/management/commands/test_hierarchy_audit.py

from django.core.management.base import BaseCommand
from django.core.exceptions import ValidationError
from django.contrib.auth import get_user_model
from django.db import transaction
import uuid
from datetime import datetime

from brands_core.models import Brand
from seo_websites_core.models import Website
from seo_pages_content.models import Page
from seo_pages_hierarchy.models import PageHierarchy, PageBreadcrumb
from seo_pages_hierarchy.filters import PageHierarchyFilter, PageBreadcrumbFilter

User = get_user_model()

class Command(BaseCommand):
    help = 'Audit complet de la hi√©rarchie des pages SEO - Identifier les probl√®mes'
    
    def add_arguments(self, parser):
        parser.add_argument(
            '--fix',
            action='store_true',
            help='Tenter de corriger les probl√®mes trouv√©s'
        )
        parser.add_argument(
            '--website-id',
            type=int,
            help='ID sp√©cifique du website √† auditer'
        )
    
    def handle(self, *args, **options):
        self.stdout.write(self.style.SUCCESS('üîç AUDIT SEO Pages Hierarchy Module\n'))
        
        # Configuration
        self.fix_issues = options.get('fix', False)
        self.website_id = options.get('website_id')
        
        # Audit des donn√©es existantes
        self.audit_existing_data()
        
        # Tests fonctionnels avec donn√©es isol√©es
        self.test_with_isolated_data()
        
        # Rapport final
        self.generate_audit_report()
        
        self.stdout.write(self.style.SUCCESS('\n‚úÖ Audit completed!'))
    
    def audit_existing_data(self):
        """Audit des donn√©es existantes"""
        self.stdout.write('\nüìä AUDIT DES DONN√âES EXISTANTES\n')
        
        # 1. V√©rifier les pages sans hi√©rarchie
        self.stdout.write('1Ô∏è‚É£ Pages sans hi√©rarchie:')
        pages_without_hierarchy = Page.objects.filter(
            hierarchy__isnull=True
        )
        
        if self.website_id:
            pages_without_hierarchy = pages_without_hierarchy.filter(website_id=self.website_id)
        
        count = pages_without_hierarchy.count()
        if count > 0:
            self.stdout.write(f'  ‚ö†Ô∏è  {count} pages sans hi√©rarchie trouv√©es')
            for page in pages_without_hierarchy[:5]:
                self.stdout.write(f'     - {page.title} ({page.url_path})')
            if count > 5:
                self.stdout.write(f'     ... et {count - 5} autres')
                
            if self.fix_issues:
                self.stdout.write('  üîß Cr√©ation des hi√©rarchies manquantes...')
                fixed = 0
                for page in pages_without_hierarchy:
                    try:
                        # D√©terminer le parent bas√© sur l'URL
                        parent_page = self._find_parent_from_url(page)
                        PageHierarchy.objects.create(
                            page=page,
                            parent=parent_page
                        )
                        fixed += 1
                    except Exception as e:
                        self.stdout.write(f'     ‚ùå Erreur pour {page.title}: {str(e)}')
                
                self.stdout.write(f'  ‚úÖ {fixed} hi√©rarchies cr√©√©es')
        else:
            self.stdout.write('  ‚úÖ Toutes les pages ont une hi√©rarchie')
        
        # 2. V√©rifier les hi√©rarchies orphelines
        self.stdout.write('\n2Ô∏è‚É£ Hi√©rarchies orphelines:')
        orphan_hierarchies = PageHierarchy.objects.filter(
            parent__isnull=False,
            parent__hierarchy__isnull=True
        )
        
        if orphan_hierarchies.exists():
            self.stdout.write(f'  ‚ö†Ô∏è  {orphan_hierarchies.count()} hi√©rarchies orphelines')
            for h in orphan_hierarchies[:5]:
                self.stdout.write(f'     - {h.page.title} ‚Üí parent sans hi√©rarchie')
        else:
            self.stdout.write('  ‚úÖ Aucune hi√©rarchie orpheline')
        
        # 3. V√©rifier les niveaux de hi√©rarchie
        self.stdout.write('\n3Ô∏è‚É£ Analyse des niveaux de hi√©rarchie:')
        self._analyze_hierarchy_levels()
        
        # 4. V√©rifier les breadcrumbs
        self.stdout.write('\n4Ô∏è‚É£ √âtat des breadcrumbs:')
        pages_with_hierarchy = Page.objects.filter(hierarchy__isnull=False)
        if self.website_id:
            pages_with_hierarchy = pages_with_hierarchy.filter(website_id=self.website_id)
            
        total_with_hierarchy = pages_with_hierarchy.count()
        pages_with_breadcrumb = pages_with_hierarchy.filter(breadcrumb_cache__isnull=False).count()
        
        self.stdout.write(f'  üìä {pages_with_breadcrumb}/{total_with_hierarchy} pages avec breadcrumb')
        
        if pages_with_breadcrumb < total_with_hierarchy:
            missing = total_with_hierarchy - pages_with_breadcrumb
            self.stdout.write(f'  ‚ö†Ô∏è  {missing} breadcrumbs manquants')
            
            if self.fix_issues:
                self.stdout.write('  üîß G√©n√©ration des breadcrumbs...')
                fixed = 0
                for page in pages_with_hierarchy.filter(breadcrumb_cache__isnull=True):
                    try:
                        breadcrumb, created = PageBreadcrumb.objects.get_or_create(page=page)
                        breadcrumb.regenerate_breadcrumb()
                        fixed += 1
                    except Exception as e:
                        self.stdout.write(f'     ‚ùå Erreur pour {page.title}: {str(e)}')
                
                self.stdout.write(f'  ‚úÖ {fixed} breadcrumbs g√©n√©r√©s')
        
        # 5. V√©rifier les contraintes d'unicit√©
        self.stdout.write('\n5Ô∏è‚É£ V√©rification des contraintes:')
        self._check_unique_constraints()
    
    def test_with_isolated_data(self):
        """Tests avec donn√©es isol√©es pour ne pas interf√©rer"""
        self.stdout.write('\n\nüß™ TESTS FONCTIONNELS AVEC DONN√âES ISOL√âES\n')
        
        # Cr√©er un namespace unique pour ce test
        test_namespace = f"test-hierarchy-{datetime.now().strftime('%Y%m%d-%H%M%S')}-{uuid.uuid4().hex[:6]}"
        
        # Utiliser une transaction pour rollback √† la fin
        with transaction.atomic():
            try:
                # Setup test data
                self.test_brand = Brand.objects.filter(seo_website__isnull=False).first()
                if not self.test_brand:
                    self.stdout.write(self.style.ERROR('‚ùå Aucune brand avec website'))
                    return
                
                self.test_website = self.test_brand.seo_website
                self.test_pages = []
                
                # Cr√©er pages de test avec namespace unique
                page_configs = [
                    ('Homepage Test', 'vitrine', f'/{test_namespace}'),
                    ('About Test', 'vitrine', f'/{test_namespace}/about'),
                    ('Services Test', 'vitrine', f'/{test_namespace}/services'),
                    ('SEO Service Test', 'produit', f'/{test_namespace}/services/seo'),
                    ('Blog Test', 'blog', f'/{test_namespace}/blog'),
                ]
                
                for title, page_type, url_path in page_configs:
                    page = Page.objects.create(
                        website=self.test_website,
                        title=f'{title} ({test_namespace})',
                        page_type=page_type,
                        url_path=url_path,
                        search_intent='TOFU'
                    )
                    self.test_pages.append(page)
                
                self.stdout.write(f'‚úÖ Cr√©√© {len(self.test_pages)} pages de test isol√©es')
                
                # Tests
                self._test_hierarchy_creation()
                self._test_hierarchy_limits()
                self._test_breadcrumb_generation()
                self._test_filters()
                
                # Rollback automatique
                raise Exception("Rollback intentionnel - Tests termin√©s")
                
            except Exception as e:
                if "Rollback intentionnel" in str(e):
                    self.stdout.write('\n‚úÖ Tests termin√©s, donn√©es de test nettoy√©es')
                else:
                    self.stdout.write(f'\n‚ùå Erreur: {str(e)}')
    
    def _find_parent_from_url(self, page):
        """Trouve le parent potentiel bas√© sur l'URL"""
        if page.url_path in ['/', '']:
            return None
            
        # Enlever le dernier segment
        parts = page.url_path.rstrip('/').split('/')
        if len(parts) <= 2:  # C'est une page de niveau 1
            # Chercher la homepage
            homepage = Page.objects.filter(
                website=page.website,
                url_path='/'
            ).first()
            return homepage
        
        # Chercher le parent par URL
        parent_path = '/'.join(parts[:-1])
        if not parent_path:
            parent_path = '/'
            
        parent_page = Page.objects.filter(
            website=page.website,
            url_path=parent_path
        ).first()
        
        return parent_page
    
    def _analyze_hierarchy_levels(self):
        """Analyse la distribution des niveaux"""
        from django.db.models import Count
        
        # Compter par niveau - m√©thode corrig√©e
        level_counts = {
            1: PageHierarchy.objects.filter(parent__isnull=True).count(),
            2: PageHierarchy.objects.filter(
                parent__isnull=False,
                parent__hierarchy__parent__isnull=True
            ).count(),
            3: PageHierarchy.objects.filter(
                parent__isnull=False,
                parent__hierarchy__parent__isnull=False,
                parent__hierarchy__parent__hierarchy__parent__isnull=True
            ).count(),
            4: PageHierarchy.objects.filter(
                parent__isnull=False,
                parent__hierarchy__parent__isnull=False,
                parent__hierarchy__parent__hierarchy__parent__isnull=False
            ).count()
        }
        
        for level, count in level_counts.items():
            if level <= 3:
                self.stdout.write(f'  Level {level}: {count} pages')
            elif count > 0:
                self.stdout.write(f'  ‚ö†Ô∏è  Level {level}: {count} pages (LIMITE D√âPASS√âE!)')
        
    
    
    def _check_unique_constraints(self):
        """V√©rifie les contraintes d'unicit√©"""
        from django.db.models import Count
        
        # Doublons URL par website
        duplicates = Page.objects.values('website', 'url_path').annotate(
            count=Count('id')
        ).filter(count__gt=1)
        
        if duplicates:
            self.stdout.write(f'  ‚ö†Ô∏è  {len(duplicates)} doublons URL d√©tect√©s!')
            for dup in duplicates[:5]:
                pages = Page.objects.filter(
                    website_id=dup['website'],
                    url_path=dup['url_path']
                )
                self.stdout.write(f'     - {dup["url_path"]}: {dup["count"]} fois')
                for p in pages:
                    self.stdout.write(f'       ‚Üí {p.title} (ID: {p.id})')
        else:
            self.stdout.write('  ‚úÖ Aucun doublon URL')
    
    def _test_hierarchy_creation(self):
        """Test cr√©ation de hi√©rarchie"""
        self.stdout.write('\nüìã Test cr√©ation hi√©rarchie:')
        
        # Cr√©er hi√©rarchie 3 niveaux
        root = self.test_pages[0]
        level2 = self.test_pages[1]
        level3 = self.test_pages[3]
        
        try:
            h1 = PageHierarchy.objects.create(page=root, parent=None)
            h2 = PageHierarchy.objects.create(page=level2, parent=root)
            h3 = PageHierarchy.objects.create(page=level3, parent=level2)
            
            self.stdout.write(f'  ‚úÖ Hi√©rarchie 3 niveaux cr√©√©e')
            self.stdout.write(f'     Level 1: {h1.get_level()}')
            self.stdout.write(f'     Level 2: {h2.get_level()}')
            self.stdout.write(f'     Level 3: {h3.get_level()}')
            
        except Exception as e:
            self.stdout.write(f'  ‚ùå Erreur cr√©ation: {str(e)}')
    
    def _test_hierarchy_limits(self):
        """Test limites hi√©rarchie"""
        self.stdout.write('\nüìã Test limite 3 niveaux:')
        
        # Trouver une page de niveau 3 parmi nos pages de test
        if len(self.test_pages) >= 5:
            # On doit chercher une page niveau 3 en utilisant la bonne syntaxe
            level3_page = None
            for page in self.test_pages:
                if hasattr(page, 'hierarchy') and page.hierarchy.get_level() == 3:
                    level3_page = page
                    break
            
            if level3_page:
                try:
                    # Tenter de cr√©er un niveau 4
                    PageHierarchy.objects.create(
                        page=self.test_pages[4],
                        parent=level3_page
                    )
                    self.stdout.write('  ‚ùå PROBL√àME: Niveau 4 autoris√©!')
                except ValidationError as e:
                    self.stdout.write('  ‚úÖ Niveau 4 correctement bloqu√©')
                    self.stdout.write(f'     Message: {str(e)}')
                except Exception as e:
                    self.stdout.write(f'  ‚ö†Ô∏è  Erreur inattendue: {str(e)}')
            else:
                self.stdout.write('  ‚ÑπÔ∏è  Pas de page niveau 3 trouv√©e pour tester')
    
    
    
    def _test_breadcrumb_generation(self):
        """Test g√©n√©ration breadcrumbs"""
        self.stdout.write('\nüìã Test breadcrumbs:')
        
        for page in self.test_pages[:3]:
            if hasattr(page, 'hierarchy'):
                try:
                    breadcrumb, created = PageBreadcrumb.objects.get_or_create(page=page)
                    data = breadcrumb.regenerate_breadcrumb()
                    self.stdout.write(f'  ‚úÖ Breadcrumb {page.title}: {len(data)} niveaux')
                except Exception as e:
                    self.stdout.write(f'  ‚ùå Erreur breadcrumb {page.title}: {str(e)}')
    
    def _test_filters(self):
        """Test des filtres"""
        self.stdout.write('\nüìã Test filtres:')
        
        # Test filtre par niveau
        for level in [1, 2, 3]:
            filter_obj = PageHierarchyFilter(data={
                'website': self.test_website.id,
                'level': level
            })
            
            if filter_obj.is_valid():
                count = filter_obj.qs.count()
                self.stdout.write(f'  ‚úÖ Filtre niveau {level}: {count} r√©sultats')
            else:
                self.stdout.write(f'  ‚ùå Filtre niveau {level} invalide')
    
    def generate_audit_report(self):
        """G√©n√®re un rapport d'audit final"""
        self.stdout.write('\n\n' + '='*60)
        self.stdout.write('üìä RAPPORT D\'AUDIT FINAL')
        self.stdout.write('='*60)
        
        # Statistiques globales
        total_pages = Page.objects.count()
        pages_with_hierarchy = Page.objects.filter(hierarchy__isnull=False).count()
        pages_with_breadcrumb = Page.objects.filter(breadcrumb_cache__isnull=False).count()
        
        hierarchy_coverage = (pages_with_hierarchy / total_pages * 100) if total_pages > 0 else 0
        breadcrumb_coverage = (pages_with_breadcrumb / total_pages * 100) if total_pages > 0 else 0
        
        self.stdout.write(f'\nüìà Couverture:')
        self.stdout.write(f'  - Pages totales: {total_pages}')
        self.stdout.write(f'  - Avec hi√©rarchie: {pages_with_hierarchy} ({hierarchy_coverage:.1f}%)')
        self.stdout.write(f'  - Avec breadcrumb: {pages_with_breadcrumb} ({breadcrumb_coverage:.1f}%)')
        
        # Recommandations
        self.stdout.write(f'\nüí° Recommandations:')
        
        if hierarchy_coverage < 100:
            self.stdout.write('  ‚ö†Ô∏è  Compl√©ter les hi√©rarchies manquantes')
            self.stdout.write('     ‚Üí Utiliser --fix pour correction automatique')
        
        if breadcrumb_coverage < 100:
            self.stdout.write('  ‚ö†Ô∏è  G√©n√©rer les breadcrumbs manquants')
            self.stdout.write('     ‚Üí Utiliser --fix pour g√©n√©ration automatique')
        
        # Points d'attention code
        self.stdout.write(f'\nüîß Points d\'attention dans le code:')
        self.stdout.write('  1. La limite 3 niveaux semble fonctionnelle')
        self.stdout.write('  2. Les filtres par niveau fonctionnent')
        self.stdout.write('  3. V√©rifier la gestion des pages orphelines')
        self.stdout.write('  4. Optimiser la r√©g√©n√©ration des breadcrumbs')
        
        self.stdout.write('\n' + '='*60 + '\n')